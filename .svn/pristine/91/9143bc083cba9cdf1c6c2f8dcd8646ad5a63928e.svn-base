package de.feu.propra18.q9512268.app.main;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import de.feu.propra18.q9512268.app.objects.Point;
import javafx.collections.ObservableList;

/**
 * TODO
 * 
 * @author Christian Luetticke
 * @version 1.0
 * @see PointsContainer
 */
public class PointsContainerHistory {

	/**
	 * Final singleton instance of the {@link PointsContainerHistory} class.
	 * <P>
	 * Gets created when accessed the first time.
	 */
	private static final PointsContainerHistory INSTANCE = new PointsContainerHistory();

	// TODO
	private Stack<byte[]> stack1;
	// TODO
	private Stack<byte[]> stack2;

	/**
	 * Private constructor which can never be called directly.
	 * <P>
	 * Only instantiated when accessing {@link PointsContainerHistory#INSTANCE} for
	 * the first time.
	 * <P>
	 * Constructs the two different stacks which realize Undo/Redo-functionality.
	 */
	private PointsContainerHistory() {
		stack1 = new Stack<byte[]>();
		stack2 = new Stack<byte[]>();
	}

	/**
	 * Get access to the {@link PointsContainerHistory#INSTANCE}.
	 * 
	 * @return The PointsContainerHistory instance.
	 */
	static PointsContainerHistory get_Instance() {
		return INSTANCE;
	}

	// TODO
	public void serialize_and_store_allPoints(ObservableList<Point> allPoints) {
		try {
			final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
			final ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
			objectOutputStream.writeObject(new ArrayList<Point>(allPoints));
			byte[] array = byteArrayOutputStream.toByteArray();

			if (stack1.isEmpty() && !(stack2.isEmpty())) {
				stack1 = (Stack<byte[]>) stack2.clone();
				stack1.push(new byte[0]);
				stack2.clear();
			}
			stack1.push(array);

			objectOutputStream.close();

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	// TODO
	List<Point> undo() {
		if (stack1.size() > 0) {
			stack2.push(stack1.pop());
			return restorePoints();
		}
		return null;
	}

	// TODO
	List<Point> redo() {
		if (stack2.size() > 0) {
			stack1.push(stack2.pop());
			return restorePoints();
		}
		return null;
	}

	// TODO
	private List<Point> restorePoints() {
		List<Point> restored = new ArrayList<Point>();
		try {
			final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(stack1.peek());
			ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
			restored = (List<Point>) objectInputStream.readObject();
			objectInputStream.close();
		} catch (Exception e) {
		}
		return restored;
	}

	// TODO
	public void clearHistory() {
		stack1.clear();
		stack2.clear();
	}

}
