package de.feu.propra18.q9512268.app.main;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import de.feu.propra18.q9512268.app.objects.Point;
import javafx.collections.ObservableList;

/**
 *  This class which is realized as a singleton provides a history for the {@link PointsContainer} instance.
 * <P>
 * It provides functionality to undo and redo actions and manages the two stacks which realize the history.
 * <P>
 * The functions provided by this class are called from {@link PointsContainer}.
 * 
 * @author Christian Luetticke
 * @version 1.0
 * @see PointsContainer
 */
class PointsContainerHistory {

	/**
	 * Final singleton instance of the {@link PointsContainerHistory} class.
	 * <P>
	 * Gets created when accessed the first time.
	 */
	private static final PointsContainerHistory INSTANCE = new PointsContainerHistory();

	/**
	 * Stack1 represents the current state which is visible to the user. 	 
	 */
	private Stack<byte[]> stack1;
	/**
	 * Stack1 represents a auxiliary structure for stack1 to realize undo and redo functionality.	 
	 */
	private Stack<byte[]> stack2;

	/**
	 * Private constructor which can never be called directly.
	 * <P>
	 * Only instantiated when accessing {@link PointsContainerHistory#INSTANCE} for
	 * the first time.
	 * <P>
	 * Constructs the two different stacks to manage the history.
	 */
	private PointsContainerHistory() {
		stack1 = new Stack<byte[]>();
		stack2 = new Stack<byte[]>();
	}

	/**
	 * Get access to the {@link PointsContainerHistory#INSTANCE}.
	 * 
	 * @return The PointsContainerHistory instance.
	 */
	static PointsContainerHistory get_Instance() {
		return INSTANCE;
	}

	/**
	 * If this function is called, the passed points are converted into an byte array and
	 * added to {@link PointsContainerHistory#stack1}.
	 * 
	 * @param allPoints List containing points to serialize and save in history.
	 * @see PointsContainer#serialize_and_store_allPoints()
	 */
	void serialize_and_store_allPoints(ObservableList<Point> allPoints) {
		try {
			final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
			final ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
			objectOutputStream.writeObject(new ArrayList<Point>(allPoints));
			byte[] array = byteArrayOutputStream.toByteArray();
			
			/*
			 * If undo actions lead to an empty canvas on the frontend and the user adds a new point,
			 * the history is reset (which means stack2 gets cleared).
			 */
			if(stack1.isEmpty() && !stack2.isEmpty()) {
				stack2.clear();
			}			
			stack1.push(array);
			
			objectOutputStream.close();

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Called by {@link PointsContainer#undo()} to undo a current action.
	 * <P>
	 * This means the top element of {@link PointsContainerHistory#stack1} is pushed onto auxiliary structure {@link PointsContainerHistory#stack2}.
	 * @return
	 * List<Point> All points after undo function completed.
	 * @see PointsContainer#undo()
	 */
	List<Point> undo() {
		
		if (stack1.size() > 0) {
			stack2.push(stack1.pop());
			return restorePoints();
		}
		return null;
	}

	/**
	 * Called by {@link PointsContainer#undo()} to redo an undone action.
	 * <P>
	 * This means the top element of {@link PointsContainerHistory#stack2} is pushed back onto {@link PointsContainerHistory#stack1}.
	 * @return
	 * List<Point> All points after redo function completed.
	 * @see PointsContainer#redo()
	 */
	List<Point> redo() {
				
		if (stack2.size() > 0) {
			stack1.push(stack2.pop());
			return restorePoints();
		}
		return null;
	}

	/**
	 * Restores points from the peek element of {@link PointsContainerHistory#stack1}.
	 * @return
	 * List<Point> The restored points.
	 */
	private List<Point> restorePoints() {
		List<Point> restored = new ArrayList<Point>();
		try {
			final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(stack1.peek());
			ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
			restored = (List<Point>) objectInputStream.readObject();
			objectInputStream.close();
		} catch (Exception e) {
		}
		return restored;
	}

	/**
	 * Completely resets the current history.
	 * 
	 * @see PointsContainer#clear_History()
	 */
	public void clearHistory() {
		stack1.clear();
		stack2.clear();
	}

}
