package de.feu.propra18.q9512268.app.main;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.EmptyStackException;
import java.util.List;
import java.util.Stack;

import de.feu.propra18.q9512268.app.objects.Point;
import de.feu.propra18.q9512268.app.objects.PointType;
import de.feu.propra18.q9512268.app.objects.SimpleCircle;
import de.feu.propra18.q9512268.gui.controller.MainController;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.transformation.SortedList;
import javafx.scene.shape.Circle;
import javafx.util.Callback;

/**
 * This class, which is realized as a singleton provides four different
 * containers which hold points and the coordinates of the convex hull.
 * <P>
 * The contents of these main data containers are bound to shapes on the
 * front-end side.
 * <P>
 * The functions provided by this class can be accessed via the
 * {@link MainFacade}.
 * 
 * @author Christian Luetticke
 * @version 1.0
 * @see MainController
 */
class PointsContainer {

	/**
	 * Final singleton instance of the {@link PointsContainer} class.
	 * <P>
	 * Gets created when accessed the first time.
	 */
	private static final PointsContainer INSTANCE = new PointsContainer();

	/**
	 * Holds all current {@link Point} of type {@link PointType#INNER} instances
	 * sorted depending on their x coordinates.
	 */
	private SortedList<Point> sortedPoints;
	/**
	 * Holds all current {@link Point} instances of type {@link PointType#INNER}.
	 */
	private ObservableList<Point> allPoints;
	/**
	 * Holds all current {@link Point} instances of type {@link PointType#OUTER}
	 * which are siblings of the points in {@link PointsContainer#allPoints}.
	 */
	private ObservableList<Point> allPointsOuter;
	/**
	 * Holds all coordinates as Double values which belong to the convex hull.
	 */
	private ObservableList<Double> convexHullPoints;

	// TODO
	private SimpleCircle largestIncludedCircle;

	// TODO
	private Stack<byte[]> stack1;
	// TODO
	private Stack<byte[]> stack2;

	/**
	 * Private constructor which can never be called directly.
	 * <P>
	 * Only instantiated when accessing {@link PointsContainer#INSTANCE} for the
	 * first time.
	 * <P>
	 * Constructs the four different containers as {@link ObservableList} instances.
	 */
	private PointsContainer() {

		allPoints = createObservablePointArrayList();
		allPointsOuter = createObservablePointArrayList();

		Comparator<Point> xComparator = (p1, p2) -> {
			int result = Double.compare(p1.getCenterX(), p2.getCenterX());
			if (result == 0) {
				return Double.compare(p1.getCenterY(), p2.getCenterY());
			}
			return result;
		};

		sortedPoints = allPoints.sorted(xComparator);
		convexHullPoints = FXCollections.observableArrayList();
		largestIncludedCircle = new SimpleCircle();

		stack1 = new Stack<byte[]>();
		stack2 = new Stack<byte[]>();

	}

	/**
	 * Creates an {@link ObservableList} which holds {@link Point} instances.
	 * <P>
	 * Uses a {@link Callback} to make sure observers are notified when
	 * {@link Point#centerXProperty()} or {@link Point#centerYProperty()} changes.
	 * 
	 * @return ObservableList An observable list for {@link Point} instances.
	 */
	private ObservableList<Point> createObservablePointArrayList() {
		return FXCollections.observableArrayList(new Callback<Point, Observable[]>() {
			@Override
			public Observable[] call(Point param) {
				return new Observable[] { param.centerXProperty(), param.centerYProperty() };
			}
		});
	}

	/**
	 * Get access to the {@link PointsContainer#INSTANCE}.
	 * 
	 * @return The PointsContainer instance.
	 */
	static PointsContainer get_Instance() {
		return INSTANCE;
	}

	/**
	 * Get access to the ObservableList containing all {@link Point} instances of
	 * type {@link PointType#INNER}.
	 * 
	 * @return ObservableList The observable list containing all INNER points.
	 * @see MainFacade#get_PointsAll()
	 */
	ObservableList<Point> get_PointsAll() {
		return allPoints;
	}

	/**
	 * Get access to the ObservableList containing all {@link Point} instances of
	 * type {@link PointType#OUTER}.
	 * 
	 * @return ObservableList The observable list containing all OUTER points.
	 * @see MainFacade#get_PointsAllOuter()
	 */

	ObservableList<Point> get_PointsAllOuter() {
		return allPointsOuter;
	}

	/**
	 * Get access to the SortedList containing all {@link Point} instances sorting
	 * regarding their x coordinate.
	 * 
	 * @return SortedList The SortedList of points.
	 * @see MainFacade#get_PointsSorted()
	 */
	SortedList<Point> get_PointsSorted() {
		return sortedPoints;
	}

	/**
	 * Get access to the ObservabelList containing all convex hull coordinates.
	 * 
	 * @return ObservableList The observable list containing all convex hull
	 *         coordinates.
	 * @see MainFacade#get_PointsConvexHull()
	 */
	ObservableList<Double> get_PointsConvexHull() {
		return convexHullPoints;
	}

	SimpleCircle get_LargestIncludedCircle() {
		return largestIncludedCircle;
	}

	/**
	 * Returns a 2D int array which contains the convex hull coordinates.
	 * 
	 * @return int[][] 2D array of convex hull values.
	 * @see MainFacade#get_PointsConvexHull_asArray()
	 */
	int[][] get_PointsConvexHull_asArray() {

		int[][] convexHull = new int[convexHullPoints.size() / 2][2];
		int i = 0;
		int j = 0;
		while (i < convexHullPoints.size() - 1) {
			int[] row = convexHull[j];
			row[0] = convexHullPoints.get(i).intValue();
			row[1] = convexHullPoints.get(i + 1).intValue();
			i = i + 2;
			j++;
		}

		return convexHull;

	}

	/**
	 * Adds a Double value to {@link PointsContainer#convexHullPoints}.
	 * 
	 * @param d
	 *            The Double value which should be added.
	 * @see MainFacade#calculate_PointsConvexHull()
	 */
	void add_PointConvexHull(Double d) {
		convexHullPoints.add(d);
	}
	
	/**
	 * Adds a new {@link Point} instance to the corresponding container depending on
	 * the {@link PointType}. Also adds its sibling.
	 * 
	 * @param p
	 *            The Point to add.
	 * @see MainFacade#add_Point(Point)
	 */
	void add_Point(Point p) {

		PointType type = p.getType();
		switch (type) {
		case INNER:
			allPoints.add(p);
			allPointsOuter.add(p.getSibling());
			break;
		case OUTER:
			allPoints.add(p.getSibling());
			allPointsOuter.add(p);
			break;
		}
	}

	/**
	 * Returns an info if a {@link Point} instance is already present in
	 * {@link PointsContainer#allPoints}.
	 * 
	 * @param p
	 *            The point to run the contains-request on.
	 * @return boolean Info if {@link PointsContainer#allPoints} contains the
	 *         requested point.
	 */
	boolean contains_Point(Point p) {
		return allPoints.contains(p);
	}

	/**
	 * Removes a {@link Point} instance to the corresponding container depending on
	 * the {@link PointType}. Also removes also its sibling.
	 * 
	 * @param p
	 *            The Point to add.
	 * @see MainFacade#remove_Point(Point)
	 */
	void remove_Point(Point p) {

		PointType type = p.getType();
		switch (type) {
		case INNER:
			allPoints.remove(p);
			allPointsOuter.remove(p.getSibling());
			break;
		case OUTER:
			allPointsOuter.remove(p);
			allPoints.remove(p.getSibling());
			break;
		}

	}

	/**
	 * Clears the observable lists {@link PointsContainer#allPoints} and
	 * {@link PointsContainer#allPointsOuter}.
	 * 
	 * @see MainFacade#clear_Container()
	 * @see MainFacade#clear_Points()
	 */
	void remove_AllPoints() {
		allPoints.clear();
		allPointsOuter.clear();
		largestIncludedCircle.clear();
	}

	void clear_History() {
		stack1.clear();
		stack2.clear();
	}

	/**
	 * Clears the observable list {@link PointsContainer#convexHullPoints}.
	 * 
	 * @see MainFacade#clear_ConvexHullPoints()
	 */
	void remove_AllConvexHullPoints() {
		convexHullPoints.clear();
	}

	public void remove_LargestIncludedCircle() {
		largestIncludedCircle.clear();

	}

	void serialize_and_store_allPoints() {
		try {
			final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
			final ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
			objectOutputStream.writeObject(new ArrayList<Point>(allPoints));
			byte[] array = byteArrayOutputStream.toByteArray();

			// Testfall: 50 Einfügen, UNDO, 1 Einfügen, UNDO UNDO UNDo..
			if (stack1.isEmpty() && !(stack2.isEmpty())) {
				stack1 = (Stack<byte[]>) stack2.clone();
				stack1.push(new byte[0]);
				stack2.clear();
			}
			stack1.push(array);

			objectOutputStream.close();

		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	void undo() {
		if (stack1.size() > 0) {
			stack2.push(stack1.pop());
			restorePoints();
		}
	}

	void redo() {
		if (stack2.size() > 0) {
			stack1.push(stack2.pop());
			restorePoints();
		}
	}

	private void restorePoints() {
		List<Point> restored = new ArrayList<Point>();

		try {
			final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(stack1.peek());
			ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
			restored = (List<Point>) objectInputStream.readObject();
			objectInputStream.close();
		} catch (Exception e) {
		}

		remove_AllPoints();
		remove_AllConvexHullPoints();
		for (int i = 0; i < restored.size(); i++) {
			Point p = restored.get(i);
			add_Point(new Point(p.getCenterX(), p.getCenterY()));
		}

	}

}
