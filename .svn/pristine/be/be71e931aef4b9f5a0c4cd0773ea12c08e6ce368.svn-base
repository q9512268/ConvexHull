package de.feu.propra18.q9512268.app.main.algorithm.circle;

import java.util.Objects;

import de.feu.propra18.q9512268.app.objects.Point;
import de.feu.propra18.q9512268.app.objects.SimpleCircle;

class Edge {

	private Edge previous;
	private Edge next;

	private final int ID;

	private double startX;
	private double startY;
	private double endX;
	private double endY;

	private SimpleCircle inkreis;

	public Edge(int id, double startX, double startY, double endX, double endY) {

		this.ID = id;
		this.startX = startX;
		this.startY = startY;
		this.endX = endX;
		this.endY = endY;

		inkreis = new SimpleCircle();

	}

	// TODO
	// DEN INKREIS IMMER BERECHNEN WENN SICH PREVIOUS ODER NEXT Ã„NDERN

	public void calculate_inkreis() {

		if(previous != null && next != null) {
			
			double A_x = previous.getStartX();
			double A_y = previous.getStartY();
			
			double B_x = previous.getEndX();
			double B_y = previous.getEndY();
			
			double C_x = this.getStartX();
			double C_y = this.getStartY();
			
			double D_x = this.getEndX();
			double D_y = this.getEndY();
			
			double E_x = next.getStartX();
			double E_y = next.getStartY();
			
			double F_x = next.getEndX();
			double F_y = next.getEndY();
			
			double dAB = Math.sqrt(Math.pow((A_x - B_x), 2) + Math.pow((A_y - B_y), 2));
			double dCD = Math.sqrt(Math.pow((C_x - D_x), 2) + Math.pow((C_y - D_y), 2));
			double dEF = Math.sqrt(Math.pow((E_x - F_x), 2) + Math.pow((E_y - F_y), 2));
			
			double a_1 = (dAB * (D_y - C_y)) - (dCD * (B_y - A_y));
			double a_2 = (dCD * (F_y - E_y)) - (dEF * (D_y - C_y));
			
			double b_1 = (dCD * (B_x - A_x)) - (dAB * (D_x - C_x));
			double b_2 = (dEF * (D_x - C_x)) - (dCD * (F_x - E_x));
			
			double y_1 = dAB * ((C_x * (D_y - C_y)) - (C_y * (D_x - C_x))) +
					dCD * ((A_y * (B_x - A_x)) - (A_x * (B_y - A_y)));
			double y_2 = dCD * ((E_x * (F_y - E_y)) - (E_y * (F_x - E_x))) +
					dEF * ((C_y * (D_x - C_x)) - (C_x * (D_y - C_y)));
			
			double dH = (a_1 * b_2) - (a_2 * b_1);
			double dU = (y_1 * b_2) - (y_2 * b_1);
			double dV = (a_1 * y_2) - (a_2 * y_1);
			
			double Mx = dU / dH;
			double My = dV / dH;
			
			this.inkreis.setX(Mx);
			this.inkreis.setY(My);
			
			double r = (((A_x - Mx)*(B_y - A_y)) + ((A_y - My)*(A_x - B_x)))/dAB;
			
			this.inkreis.setRadius(r*-1);
			
			
			
			
			
		}
	}

	public Edge getPrevious() {
		return previous;
	}

	public void setPrevious(Edge previous) {
		this.previous = previous;
		calculate_inkreis();
	}

	public Edge getNext() {
		return next;
	}

	public void setNext(Edge next) {
		this.next = next;
		calculate_inkreis();
	}

	public SimpleCircle getInkreis() {
		return inkreis;
	}

	public int getID() {
		return ID;
	}

	public double getStartX() {
		return startX;
	}

	public void setStartX(double startX) {
		this.startX = startX;
	}

	public double getStartY() {
		return startY;
	}

	public void setStartY(double startY) {
		this.startY = startY;
	}

	public double getEndX() {
		return endX;
	}

	public void setEndX(double endX) {
		this.endX = endX;
	}

	public double getEndY() {
		return endY;
	}

	public void setEndY(double endY) {
		this.endY = endY;
	}
	
	

	/**
	 * Override hashCode method to create hash for {@link Point} instance only based
	 * on its initial x and y coordinates. Necessary to keep a constant hashCode
	 * while dragging a point on the canvas.
	 */
	@Override
	public int hashCode() {
		return Objects.hash(startX, startY, endX, endY);
	}

	/**
	 * Override equals method to compare to {@link Point} instance only based on its
	 * x and y coordinates.
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Edge other = (Edge) obj;
		if (getStartX() != other.getStartX())
			return false;
		if (getStartY() != other.getStartY())
			return false;
		if (getEndX() != other.getEndX())
			return false;
		if (getEndY() != other.getEndY())
			return false;
		return true;
	}

	@Override
	public String toString() {

		if (previous != null && next != null) {
			return "[ " + this.hashCode() + " ](((( " + ID + " )))) " + "previous = " + previous.ID + " [[[[" + startX + "/" + startY + "/" + endX
					+ "/" + endY + ", r=" + inkreis.getRadius().doubleValue() + "]]]] " + "next = " + next.ID;
		}
		if (previous != null) {
			return "[ " + this.hashCode() + " ] (((( " + ID + " )))) " + "previous = " + previous.startX + "/" + previous.startY + "/"
					+ previous.endX + "/" + previous.endY + " [[[[" + startX + "/" + startY + "/" + endX + "/" + endY
					+ ", r=" + inkreis.getRadius().doubleValue() + "]]]] next = null";
		} else if (next != null) {
			return "[ " + this.hashCode() + " ] (((( " + ID + " )))) " + "previous = null " + " [[[[" + startX + "/" + startY + "/" + endX + "/"
					+ endY + ", r=" + inkreis.getRadius().doubleValue() + "]]]] " + "next = " + next.startX + "/"
					+ next.startY + "/" + next.endX + "/" + next.endY;

		}

		return "[ " + this.hashCode() + " ] (((( " + ID + " )))) " + "previous = null " + " [[[[" + startX + "/" + startY + "/" + endX + "/" + endY
				+ ", r=" + inkreis.getRadius().doubleValue() + "]]]] " + "next = null";

	}

}
