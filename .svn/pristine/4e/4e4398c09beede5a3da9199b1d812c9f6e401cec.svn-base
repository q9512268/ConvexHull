package de.feu.propra18.q9512268.app.main;

import java.util.List;
import java.util.Set;

import de.feu.propra18.q9512268.app.io.IOFacade;
import de.feu.propra18.q9512268.app.main.algorithm.circle.CircleAlgorithm;
import de.feu.propra18.q9512268.app.main.algorithm.hull.HullAlgorithm;
import de.feu.propra18.q9512268.app.objects.Point;
import de.feu.propra18.q9512268.app.objects.PointType;
import de.feu.propra18.q9512268.app.objects.SimpleCircle;
import de.feu.propra18.q9512268.app.objects.SimplePoint;
import de.feu.propra18.q9512268.gui.controller.MenuController;
import de.feu.propra18.q9512268.gui.controller.ToolBarController;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.transformation.SortedList;
import javafx.stage.FileChooser;

/**
 * This class, realized as a singleton instance, provides access to the main
 * functions of the application. It encapsulates access to the {@link IOFacade}
 * and the {@link PointsContainer}.
 * 
 * @author Christian Luetticke
 * @version 1.0
 */
public class MainFacade {

	/**
	 * Final singleton instance of the {@link MainFacade} class.
	 * <P>
	 * Gets created when accessed the first time.
	 */
	private static final MainFacade INSTANCE = new MainFacade();

	/**
	 * Reference to the {@link IOFacade} singleton instance.
	 */
	private IOFacade IOFACADE;
	/**
	 * Reference to the {@link PointsContainer} singleton instance.
	 */
	private PointsContainer CONTAINER;

	/**
	 * Private constructor which can never be called directly.
	 * <P>
	 * Only instantiated when accessing {@link MainFacade#INSTANCE} for the first
	 * time.
	 * <P>
	 * Gets a reference to the IOFacade and the PointsContainer singleton instances.
	 */
	private MainFacade() {
		this.IOFACADE = IOFacade.getInstance();
		this.CONTAINER = PointsContainer.get_Instance();
	}

	/**
	 * Get access to the {@link MainFacade#INSTANCE}.
	 * 
	 * @return The MainFacade instance.
	 */
	public static MainFacade get_Instance() {
		return INSTANCE;
	}

	/**
	 * Add a new {@link Point} to {@link PointsContainer}.
	 * <P>
	 * Delegates request to {@link PointsContainer#add_Point(Point)}
	 * 
	 * @param p
	 *            The Point to add.
	 * @see PointsContainer#get_PointsAll()
	 * @see PointsContainer#get_PointsAllOuter()
	 * @see PointsContainer#get_PointsSorted()
	 */
	public void add_Point(Point p) {
		CONTAINER.add_Point(p);
	}

	/**
	 * Can be called when random {@link Point} instances should be added to the
	 * visible canvas. Delegates request to
	 * {@link MainFacade#pointsRandom(int, double, double)}
	 * 
	 * @param amount
	 *            How many points should be added.
	 * @param width
	 *            Width of the area in which random points should be generated.
	 * @param height
	 *            Height of the area in which random points should be generated.
	 * @see ToolBarController
	 */
	public void add_PointsRandom(int amount, double width, double height) {
		pointsRandom(amount, width, height);
		snapshot_AllPoints();
	}

	/**
	 * Delegates request to add {@link Point} instances from a 2D array to
	 * {@link IOFacade#add_PointsFromArray(int[][])}.
	 * 
	 * @param pointArray
	 *            2D array of x/y coordinates.
	 */
	public void add_PointsFromArray(int[][] pointArray) {
		IOFACADE.add_PointsFromArray(pointArray);
		snapshot_AllPoints();
	}

	/**
	 * Takes as input a fileName pointing to a file containing point coordinates.
	 * <P>
	 * Delegates the request to {@link IOFacade#add_PointsFromFile(String)}.
	 * 
	 * @param fileName
	 *            The name of the file to be read. void
	 */
	public void add_PointsFromFile(String fileName) {
		IOFACADE.add_PointsFromFile(fileName);
		snapshot_AllPoints();
	}

	/**
	 * Remove an existing {@link Point} from {@link PointsContainer}.
	 * <P>
	 * Delegates request to {@link PointsContainer#remove_Point(Point)}
	 * 
	 * @param p
	 *            The Point to be removed.
	 * @see PointsContainer#get_PointsAll()
	 * @see PointsContainer#get_PointsAllOuter()
	 * @see PointsContainer#get_PointsSorted()
	 */
	public void remove_Point(Point p) {
		CONTAINER.remove_Point(p);
		snapshot_AllPoints();
	}

	/**
	 * Method to verify a {@link Point} instance already exists.
	 * <P>
	 * Delegates request to {@link PointsContainer#contains_Point(Point)}
	 * 
	 * @param p
	 *            The point to search for.
	 * @return boolean
	 */
	public boolean contains_Point(Point p) {
		return CONTAINER.contains_Point(p);
	}

	/**
	 * To call when all current {@link Point} instances that belong to the convex
	 * hull should be removed.
	 * <P>
	 * Delegates call to {@link PointsContainer#remove_AllConvexHullPoints()}.
	 */
	public void clear_ConvexHullPoints() {
		CONTAINER.remove_AllConvexHullPoints();
	}

	/**
	 * To call when all current {@link Point} instances (also those which belong to
	 * the convex hull) should be removed.
	 * 
	 * @see PointsContainer#remove_AllPoints()
	 * @see PointsContainer#remove_AllConvexHullPoints()
	 */
	public void clear_Container() {
		CONTAINER.remove_AllPoints();
		CONTAINER.remove_AllConvexHullPoints();
		CONTAINER.remove_GEK();
		CONTAINER.clear_History();
	}

	/**
	 * Returns all current {@link Point} instances of type {@link PointType#INNER}.
	 * 
	 * @return ObservableList The observable list containing the current points of
	 *         type {@link PointType#INNER}.
	 * @see PointsContainer#get_PointsAll()
	 */
	public ObservableList<Point> get_PointsAll() {
		return CONTAINER.get_PointsAll();
	}

	/**
	 * Returns all current {@link Point} instances of type {@link PointType#OUTER}.
	 * 
	 * @return ObservableList The observable list containing the current points of
	 *         type {@link PointType#OUTER}.
	 * @see PointsContainer#get_PointsAllOuter()
	 */
	public ObservableList<Point> get_PointsAllOuter() {
		return CONTAINER.get_PointsAllOuter();
	}

	/**
	 * Returns all current {@link Point} instances of Type {@link PointType#INNER}
	 * sorted depending on their x coordinates.
	 * 
	 * @return SortedList The ObservableList containing the current points sorted.
	 * @see PointsContainer#get_PointsSorted()
	 */
	public SortedList<Point> get_PointsSorted() {
		return CONTAINER.get_PointsSorted();
	}

	/**
	 * Returns all current coordinates that belong to the convex hull.
	 * <P>
	 * Coordinates are represented as Double values to bind them to the polygon
	 * created in {@link MenuController}.
	 * 
	 * @return ObservableList The observable list containing the current convex hull
	 *         points represented by Double values.
	 * @see PointsContainer#get_PointsConvexHull()
	 */
	public ObservableList<Double> get_PointsConvexHull() {
		return CONTAINER.get_PointsConvexHull();
	}

	// TODO
	public SimpleCircle get_GEK() {
		return CONTAINER.get_GEK();
	}

	/**
	 * Returns all current {@link Point} instances that belong to the convex hull in
	 * form of a 2D int array. Delegates request to
	 * {@link PointsContainer#get_PointsConvexHull_asArray()}
	 * 
	 * @return int[][]
	 */
	public int[][] get_PointsConvexHull_asArray() {
		return CONTAINER.get_PointsConvexHull_asArray();
	}

	/**
	 * Delegates the request to export points to a file to
	 * {@link IOFacade#save_PointsToFile(String, java.util.List)}.
	 * <P>
	 * Passes current {@link Point} instances from Type {@link PointType#INNER} in
	 * form of an unmodifiableObservableList to {@link IOFacade}.
	 * 
	 * @param fileName
	 *            Name of file to export points to.
	 */
	public void save_PointsToFile(String fileName) {
		IOFACADE.save_PointsToFile(fileName, FXCollections.unmodifiableObservableList(get_PointsAll()));
	}

	/**
	 * Get access to the customized file chooser.
	 * <P>
	 * Delegates request to {@link IOFacade#get_FileChooser()}.
	 * 
	 * @return The FileChooser instance.
	 */
	public FileChooser get_FileChooser() {
		return IOFACADE.get_FileChooser();
	}

	/**
	 * Is called when the convex hull should be calculated.
	 * <P>
	 * This method makes a call to {@link HullAlgorithm#getConvexHull()}, loops
	 * through the results in form of {@link SimplePoint} instances and adds the
	 * corresponding x and y coordinates to the convex hull.
	 * 
	 * @see PointsContainer#add_PointConvexHull(Double)
	 */
	public void calculate_PointsConvexHull() {

		if (!get_PointsAll().isEmpty()) {
			final Set<SimplePoint> convexHullNodes = HullAlgorithm.getConvexHull();

			for (SimplePoint node : convexHullNodes) {
				CONTAINER.add_PointConvexHull((double) node.getX());
				CONTAINER.add_PointConvexHull((double) node.getY());
			}
		}

	}

	// TODO correct algorithm
	public void calculate_GEK() {

		if (!get_PointsAll().isEmpty()) {
			
			final List<Double> circleInfo = CircleAlgorithm.getGEKInfo();
			
			CONTAINER.setGEK_X(circleInfo.get(0));
			CONTAINER.setGEK_Y(circleInfo.get(1));
			CONTAINER.setGEK_Radius(circleInfo.get(2));
		}

	}

	/**
	 * Called from {@link MainFacade#add_PointsRandom(int, double, double)} when
	 * random {@link Point} instances should be added to the visible canvas.
	 * 
	 * @param amount
	 *            How many points should be added.
	 * @param width
	 *            Width of the area in which random points should be generated.
	 * @param height
	 *            Height of the area in which random points should be generated.
	 * @see PointsContainer#add_Point(Point)
	 * @see ToolBarController
	 */
	void pointsRandom(int amount, double width, double height) {

		final int max_width = (int) width;
		final int max_height = (int) height;

		int i = 0;
		while (i < amount) {

			int x = (int) (Math.random() * max_width);
			int y = (int) (Math.random() * max_height);

			Point p = new Point(x, y);
			if (!CONTAINER.contains_Point(p)) {
				CONTAINER.add_Point(p);
				i++;
			}
		}
	}

	public void snapshot_AllPoints() {
		CONTAINER.serialize_and_store_allPoints();
	}

	public void undo() {
		CONTAINER.undo();
		calculate_PointsConvexHull();
		calculate_GEK();
	}

	public void redo() {
		CONTAINER.redo();
		calculate_PointsConvexHull();
		calculate_GEK();
	}
}
