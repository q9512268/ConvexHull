package de.feu.propra18.q9512268.app.main;

import java.util.Comparator;

import de.feu.propra18.q9512268.app.objects.Point;
import de.feu.propra18.q9512268.app.objects.PointType;
import de.feu.propra18.q9512268.gui.controller.MainController;
import javafx.beans.Observable;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.transformation.SortedList;
import javafx.util.Callback;

/**
 * This class, which is realized as a singleton provides four different
 * containers which hold points and the coordinates of the convex hull.
 * <P>
 * This class provides the four main data containers which are used to generate
 * shapes on the front-end side.
 * <P>
 * The functions provided by this class can be accessed via the
 * {@link MainFacade}.
 * 
 * @author Christian Luetticke
 * @version 1.0
 * @see MainController}
 */
class PointsContainer {

	/**
	 * Final singleton instance of the {@link PointsContainer} class. <P>
	 * Gets created when accessed the first time.
	 */
	private static final PointsContainer INSTANCE = new PointsContainer();

	/**
	 * Holds all current {@link Point} of type {@link PointType#INNER} instances
	 * sorted depending on their x coordinates.
	 */
	private SortedList<Point> sortedPoints;
	/**
	 * Holds all current {@link Point} instances of type {@link PointType#INNER}.
	 */
	private ObservableList<Point> allPoints;
	/**
	 * Holds all current {@link Point} instances of type {@link PointType#OUTER}
	 * which are siblings of the points in {@link PointsContainer#allPoints}.
	 */
	private ObservableList<Point> allPointsOuter;
	/**
	 * Holds alls coordinates as Double values which belong to the convex hull.
	 */
	private ObservableList<Double> convexHullPoints;

	/**
	 * Private constructor which can never be called directly.
	 * <P>
	 * Only instantiated when accessing {@link PointsContainer#INSTANCE} for the
	 * first time.
	 * <P>
	 * Constructs the four different containers as {@link ObservableList} instances.
	 */
	private PointsContainer() {

		allPoints = createObservablePointArrayList();
		allPointsOuter = createObservablePointArrayList();

		Comparator<Point> xComparator = (p1, p2) -> {
			int result = Double.compare(p1.getCenterX(), p2.getCenterX());
			if (result == 0) {
				return Double.compare(p1.getCenterY(), p2.getCenterY());
			}
			return result;
		};

		sortedPoints = allPoints.sorted(xComparator);
		convexHullPoints = FXCollections.observableArrayList();

	}

	/**
	 * Creates and {@link ObservableList} which holds {@link Point} instances. <P>
	 * Uses a {@link Callback} to make sure observers are notified when
	 * {@link Point#centerXProperty()} or {@link Point#centerYProperty()} changes.
	 * 
	 * @return ObservableList<Point> An observable list for {@link Point} instances.
	 */
	private ObservableList<Point> createObservablePointArrayList() {
		return FXCollections.observableArrayList(new Callback<Point, Observable[]>() {
			@Override
			public Observable[] call(Point param) {
				return new Observable[] { param.centerXProperty(), param.centerYProperty() };
			}
		});
	}

	/**
	 * Get access to the {@link PointsContainer#INSTANCE}.
	 * 
	 * @return The PointsContainer instance.
	 */
	static PointsContainer get_Instance() {
		return INSTANCE;
	}

	/**
	 * Get access to the ObservableList containing all {@link Point} instances of
	 * type {@link PointType#INNER}.
	 * 
	 * @return ObservableList<Point>
	 * @see MainFacade#get_PointsAll()}
	 */
	ObservableList<Point> get_PointsAll() {
		return allPoints;
	}

	/**
	 * Get access to the ObservableList containing all {@link Point} instances of
	 * type {@link PointType#OUTER}.
	 * 
	 * @return ObservableList<Point>
	 * @see MainFacade#get_PointsAllOuter()}
	 */

	ObservableList<Point> get_PointsAllOuter() {
		return allPointsOuter;
	}

	/**
	 * Get access to the ObservableList containing all {@link Point} instances
	 * sorting regarding their x coordinate.
	 * 
	 * @return ObservableList<Point>
	 * @see MainFacade#get_PointsSorted()}
	 */
	SortedList<Point> get_PointsSorted() {
		return sortedPoints;
	}

	/**
	 * Get access to the ObservabelList containing all convex hull coordinates.
	 * 
	 * @return ObservableList<Double>
	 * @see MainFacade#get_PointsConvexHull()}
	 */
	ObservableList<Double> get_PointsConvexHull() {
		return convexHullPoints;
	}

	/**
	 * Returns a 2D int array which contains the convex hull coordinates.
	 * 
	 * @return int[][] 2D array of convex hull values.
	 * @see MainFacade#get_PointsConvexHull_asArray()}
	 */
	int[][] get_PointsConvexHull_asArray() {

		int[][] convexHull = new int[convexHullPoints.size() / 2][2];
		int i = 0;
		int j = 0;
		while (i < convexHullPoints.size() - 1) {
			int[] row = convexHull[j];
			row[0] = convexHullPoints.get(i).intValue();
			row[1] = convexHullPoints.get(i + 1).intValue();
			i = i + 2;
			j++;
		}

		return convexHull;

	}

	/**
	 * Adds a Double value to {@link PointsContainer#convexHullPoints}.
	 * 
	 * @param d
	 *            The Double value which should be added.
	 * @see MainFacade#calculate_PointsConvexHull()}
	 */
	void add_PointConvexHull(Double d) {
		convexHullPoints.add(d);
	}

	/**
	 * Adds a new {@link Point} instance to the corresponding container depending on
	 * the {@link PointType}. Also adds its sibling.
	 * 
	 * @param d
	 *            The Point to add.
	 * @see MainFacade#add_Point(Point)}
	 */
	void add_Point(Point p) {

		PointType type = p.getType();
		switch (type) {
		case INNER:
			allPoints.add(p);
			allPointsOuter.add(p.getSibling());
			break;
		case OUTER:
			allPoints.add(p.getSibling());
			allPointsOuter.add(p);
			break;
		}
	}

	/**
	 * Returns an info if a {@link Point} instance is already present in
	 * {@link PointsContainer#allPoints}.
	 * 
	 * @param p
	 *            The point to run the contains-request on.
	 * @return boolean Info if {@link PointsContainer#allPoints} contains the
	 *         requested point.
	 */
	boolean contains_Point(Point p) {
		return allPoints.contains(p);
	}

	/**
	 * Removes a {@link Point} instance to the corresponding container depending on
	 * the {@link PointType}. Also removes also its sibling.
	 * 
	 * @param d
	 *            The Point to add.
	 * @see MainFacade#remove_Point(Point)}
	 */
	void remove_Point(Point p) {

		PointType type = p.getType();
		switch (type) {
		case INNER:
			allPoints.remove(p);
			allPointsOuter.remove(p.getSibling());
			break;
		case OUTER:
			allPointsOuter.remove(p);
			allPoints.remove(p.getSibling());
			break;
		}

	}

	/**
	 * Clears the observable lists {@link PointsContainer#allPoints} and {@link PointsContainer#allPointsOuter}.
	 * 
	 * @see MainFacade#clear_Container()
	 * @see MainFacade#clear_Points()
	 */
	void remove_AllPoints() {
		allPoints.clear();
		allPointsOuter.clear();
	}

	/**
	 * Clears the observable list {@link PointsContainer#convexHullPoints}.
	 * 
	 * @see MainFacade#clear_ConvexHullPoints()
	 */
	void remove_AllConvexHullPoints() {
		convexHullPoints.clear();
	}

}
